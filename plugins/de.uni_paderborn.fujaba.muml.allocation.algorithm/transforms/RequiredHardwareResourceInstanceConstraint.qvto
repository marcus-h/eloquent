import Expressions;
import OCLEvaluator;
import TupleAccessor;
import Util;
import Variables;
import VariableHelper;

modeltype allocationSpecification uses cs('http://www.fujaba.de/muml/allocation/language/0.1.0/cs');
modeltype oclcontext uses oclcontext('http://www.fujaba.de/muml/allocation/language/0.1.0/oclcontext');
modeltype core uses core('http://www.storydriven.org/core/0.3.1');
modeltype ilptype uses ilp('http://www.fujaba.de/muml/allocation/ilp/0.1.0');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/expressions/0.3.1');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/expressions/common/0.3.1');
modeltype instance uses muml::instance('http://www.fujaba.de/muml/instance/0.4.0');
modeltype hwpinstance uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/hwplatforminstance/1.0/');
modeltype hwrinstance uses hardware::hwresourceinstance('http://www.fujaba.de/muml/hardware/hwresourceinstance/1.0/');
modeltype values uses values('http://ww.eclipse.org/OCL/Values');


library RequiredHardwareResourceInstanceConstraint;

// the implementation of the differentLocation constraint differs from the approach,
// which was described in my thesis

helper SpecificationCS::createHWResInstanceConstraints(inout ilp : IntegerLinearProgram,
	cic : ComponentInstanceConfiguration,
	hpic : HWPlatformInstanceConfiguration) {
	//self.getSameLocationConstraints()->createLocationConstraint(ilp, cic, hpic);
	//self.getDifferentLocationConstraints()->createLocationConstraint(ilp, cic, hpic);
	self.getHWResInstanceConstraints()->createHwResInstanceConstraint(ilp, cic, hpic);
}

helper RequiredHardwareResourceInstanceConstraintCS::createHwResInstanceConstraint(inout ilp : IntegerLinearProgram,
	cic : ComponentInstanceConfiguration,
	hpic : HWPlatformInstanceConfiguration) {
	var oclContext : OCLContext := createOCLContext(cic, hpic);
	log("SORT");
	var sequences : Sequence(Sequence(NamedElement)) := self.evaluateOCL(oclContext)
		->collectNested(toSequence())
		->sortTupleDescriptorEntries(); 
	log("SORT");
	sequences->createHelperVariablesAndConstraints(ilp);
	while (sequences->notEmpty()) {
		var cur : Sequence(NamedElement) := sequences->first();
		var todo : Sequence(Sequence(NamedElement)) := cur->getAssociatedSequences(sequences);
		sequences := sequences->reject(seq | todo->includes(seq));
		todo->createConstraintExpression(ilp, self)
	};
}

query getOddNumbers(lower : Integer, upper : Integer) : OrderedSet(Integer) {
	return OrderedSet{lower .. upper}->select(i | i.mod(2) = 1);
}

query Sequence(Sequence(NamedElement))::sortTupleDescriptorEntries() : Sequence(Sequence(NamedElement)) {
	return self->collectNested(seq |
		let indexes : OrderedSet(Integer) = getOddNumbers(1, seq->size())
		in
		indexes->collectNested(i | Sequence{seq->at(i), seq->at(i + 1)})
			->sortedBy(s | s->getVariableName())->flatten()
	)->sortedBy(seq | seq->getVariableName()); // this sort is needed, because we have just ordered the "internal" sequences so far
}

/*query TupleValue::toSequences() : Sequence(Sequence(NamedElement)) {
	return let sequence : Sequence(NamedElement) = self.toSequence()
	in
	let indexes : OrderedSet(Integer) = getOddNumbers(1, sequence->size())
	in
	indexes->collectNested(i | sequence->subSequence(i, i + 1));
}*/

query Sequence(NamedElement)::getAssociatedSequences(sequence : Sequence(Sequence(NamedElement)))
	: Sequence(Sequence(NamedElement)) {
	return sequence->select(seq |
		let indexes : OrderedSet(Integer) = getOddNumbers(1, sequence->size())
		in
		indexes->collect(i |
			seq->at(i)
		)->asBag() = indexes->collect(i | self->at(i))->asBag()
	);
}

helper Sequence(Sequence(NamedElement))::createConstraintExpression(inout ilp : IntegerLinearProgram,
	constraintCS : RequiredHardwareResourceInstanceConstraintCS) {
	log("createHWRESConstraintExpression");
	self->print();
	var comment : String := if constraintCS.name <> '' then constraintCS.name else null endif;
	ilp.constraints += self->createAdditionConstraintExpression('1', comment);
	log("createHWRESConstraintExpression");
}

query SpecificationCS::getHWResInstanceConstraints() : OrderedSet(RequiredHardwareResourceInstanceConstraintCS) {
	return self.constraints
		->select(oclIsKindOf(RequiredHardwareResourceInstanceConstraintCS))
		->collect(oclAsType(RequiredHardwareResourceInstanceConstraintCS))
		->asOrderedSet();
}