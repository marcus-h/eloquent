import OCLEvaluator;
import TupleAccessor;
import Util;
import Variables;

modeltype allocationSpecification uses cs('http://www.fujaba.de/muml/allocation/language/0.1.0/cs');
modeltype context uses context('http://www.fujaba.de/muml/allocation/language/0.1.0/context');
modeltype core uses core('http://www.storydriven.org/core/0.3.1');
modeltype ilptype uses ilp('http://www.fujaba.de/muml/allocation/ilp/0.1.0');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/expressions/0.3.1');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/expressions/common/0.3.1');
modeltype instance uses muml::instance('http://www.fujaba.de/muml/instance/0.4.0');
modeltype hwpinstance uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/hwplatforminstance/1.0/');
modeltype hwrinstance uses hardware::hwresourceinstance('http://www.fujaba.de/muml/hardware/hwresourceinstance/1.0/');
modeltype values uses values('http://ww.eclipse.org/OCL/Values');


library RequiredHardwareResourceInstanceConstraint;

// the implementation of the differentLocation constraint differs from the approach,
// which was described in my thesis

helper SpecificationCS::createHWResInstanceConstraints(inout ilp : IntegerLinearProgram,
	cic : ComponentInstanceConfiguration,
	hpic : HWPlatformInstanceConfiguration) {
	//self.getSameLocationConstraints()->createLocationConstraint(ilp, cic, hpic);
	//self.getDifferentLocationConstraints()->createLocationConstraint(ilp, cic, hpic);
	self.getHWResInstanceConstraints()->createHwResInstanceConstraint(ilp, cic, hpic);
}

helper RequiredHardwareResourceInstanceConstraintCS::createHwResInstanceConstraint(inout ilp : IntegerLinearProgram,
	cic : ComponentInstanceConfiguration,
	hpic : HWPlatformInstanceConfiguration) {
	var oclContext : OCLContext := createOCLContext(cic, hpic);
	var res : Sequence(TupleValue) := self.evaluateOCL(oclContext);
	res->forEach(tv) {
		log("createhwres");
		tv.toSequence()->forEach(elm) {
			log(elm.name);
		};
	};
}

helper Sequence(NamedElement)::createConstraintExpression(inout ilp : IntegerLinearProgram,
	constraintCS : RequiredHardwareResourceInstanceConstraintCS) {
	var comment : String := if constraintCS.name <> '' then constraintCS.name else constraintCS.repr() endif;
	var lhs : Expression := null;
	var sequences : Sequence(Sequence(NamedElement)) := Sequence{};
	var i : Integer := 1;
	var n : Integer := constraintCS.tupleDescriptors->size();
	var maxNum : Integer := self->size().div(n);
	while (i < maxNum) {
		sequences := sequences->append(self->subSequence(i, i + 2 * n));
	};
	/* self.getSequences(sequences)->reverse()->collectNested(oclAsType(Sequence(NamedElement)))->forEach(seq) {
		var variableExpression : VariableExpression := new VariableExpression(seq->getVariable()); 
		if (lhs.oclIsUndefined()) then
			lhs := variableExpression
		else
			lhs := new ArithmeticExpression(variableExpression, lhs, ArithmeticOperator::PLUS)
		endif;
	};
	var lit : String := if locationConstraint.type = LocationConstraintTypes::SAME_LOCATION then '1' else '0' endif;
	return new ConstraintExpression(lhs, new LiteralExpression(lit),
		ComparingOperator::EQUAL, comment);*/
}

query SpecificationCS::getHWResInstanceConstraints() : OrderedSet(RequiredHardwareResourceInstanceConstraintCS) {
	return self.constraints
		->select(oclIsKindOf(RequiredHardwareResourceInstanceConstraintCS))
		->collect(oclAsType(RequiredHardwareResourceInstanceConstraintCS))
		->asOrderedSet();
}