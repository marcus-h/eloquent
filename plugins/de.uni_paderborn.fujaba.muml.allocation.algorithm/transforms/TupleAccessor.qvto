import de.uni_paderborn.fujaba.muml.allocation.algorithm.ocl.TupleAccessorBlackboxUnit;
import Util;

modeltype allocationSpecification uses cs('http://www.fujaba.de/muml/allocation/language/0.1.0/cs');
modeltype core uses core('http://www.storydriven.org/core/0.3.1');
modeltype values uses values('http://ww.eclipse.org/OCL/Values');

library TupleAccessor;

helper TupleValue::get(namedPart : String) : OclAny {
	//log("resolve call: ");
	var source : ConstraintCS := self.invresolveone(ConstraintCS);
	//log(source.toString());
	return getPart(self, namedPart, source);
}

helper TupleValue::getSequence(namedPart : String) : Sequence(TupleValue) {
	var source : ConstraintCS := self.invresolveone(ConstraintCS);
	return getSequencePart(self, namedPart, source);
}

query TupleValue::toSequence() : Sequence(NamedElement) {
	// it might be possible that source is not the source we expect:
	// source might be a previously transformed constraint. This is no problem
	// because we the toSequence call will return the _expected_ sequence.
	// Alternatively, we can fix this be doing an invresolve(...)->last() or
	// ->first() (to be investigated) to get the "correct"/expected constraint
	// (implicit assumption: the tuple value is only accessed during the transformation
	// of the constraint)
	var source : ConstraintCS := self.invresolveone(ConstraintCS);
	return source.toSequence(self);
}

query LocationConstraintCS::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	var tupleDescriptor : LocationTupleDescriptorCS := self.tupleDescriptor;
	return Sequence{tupleValue.get(tupleDescriptor.instance).oclAsType(NamedElement),
		tupleValue.get(tupleDescriptor.secondInstance).oclAsType(NamedElement)}; 
}

query OrderedSet(ComponentResourceTupleDescriptorCS)::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	return self->collect(td |
		Sequence{
			tupleValue.get(td.instance).oclAsType(NamedElement),
			tupleValue.get(td.hwresinstance).oclAsType(NamedElement)
		}
	);
}

query RequiredHardwareResourceInstanceConstraintCS::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	return self.tupleDescriptors->toSequence(tupleValue);
}

query ResourceConstraintCS::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	// unfortunately we cannot check if tupleValue corresponds to an "inner" tuple
	// (well... we could do this via a blackbox but it is probably not worth the effort)
	// => we assume that the caller knows what he/she is doing
	return self.tupleDescriptors->toSequence(tupleValue);
}

query ConstraintCS::toSequence(tupleValue : TupleValue) : Sequence(NamedElement) {
	// should not happen
	assert fatal (false) with log("add constraint specific ::toSequence mapping for " + self.toString());
	return null;
}