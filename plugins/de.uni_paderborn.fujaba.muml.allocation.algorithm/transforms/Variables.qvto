import Expressions;
import Util;

modeltype core uses core('http://www.storydriven.org/core/0.3.1');
modeltype ilptype uses ilp('http://www.fujaba.de/muml/allocation/ilp/0.1.0');
modeltype expressions uses core::expressions('http://www.storydriven.org/core/expressions/0.3.1');
modeltype common uses core::expressions::common('http://www.storydriven.org/core/expressions/common/0.3.1');
modeltype instance uses muml::instance('http://www.fujaba.de/muml/instance/0.4.0');
modeltype hwpinstance uses hardware::hwplatforminstance('http://www.fujaba.de/muml/hardware/hwplatforminstance/1.0/');
modeltype hwrinstance uses hardware::hwresourceinstance('http://www.fujaba.de/muml/hardware/hwresourceinstance/1.0/');

library Variables;

helper Sequence(NamedElement)::createHelperVariablesAndConstraints(inout ilp : IntegerLinearProgram) : Variable {
	var variable : Variable := self->getVariable();
	if (not variable.oclIsUndefined()) then {
		return variable;
	} endif;
	var left : Sequence(NamedElement) := self->subSequence(1, self->size() - 2);
	var right : Sequence(NamedElement) := self->subSequence(3, self->size());
	var leftVariable : Variable := left->createHelperVariablesAndConstraints(ilp);
	var rightVariable : Variable := right->createHelperVariablesAndConstraints(ilp);
	variable := self->map createBinaryVariable();
	ilp.variables += variable;
	createHelperVariableConstraints(ilp, leftVariable, rightVariable, variable);
	return variable;
}

query Sequence(NamedElement)::getVariable() : Variable {
	return Sequence{self}.resolveone(Variable);
}

helper createHelperVariableConstraints(inout ilp : IntegerLinearProgram, leftVariable : Variable,
	rightVariable : Variable, variable : Variable) {
	ilp.constraints += createHelperVariableConstraint(leftVariable, variable);
	ilp.constraints += createHelperVariableConstraint(rightVariable, variable);
	ilp.constraints += createHelperVariableConstraint(leftVariable, rightVariable, variable);
}

helper createHelperVariableConstraint(reducedVariable : Variable, variable : Variable) : ConstraintExpression {
	return new ConstraintExpression(new VariableExpression(variable),
		new VariableExpression(reducedVariable), ComparingOperator::LESS_OR_EQUAL, null);
}

helper createHelperVariableConstraint(leftVariable : Variable,
	rightVariable : Variable, variable : Variable) : ConstraintExpression {
	return new ConstraintExpression(
		new ArithmeticExpression(
			new VariableExpression(leftVariable),
			new VariableExpression(rightVariable),
			ArithmeticOperator::PLUS
		),
		new ArithmeticExpression(
			new LiteralExpression('1'),
			new VariableExpression(variable),
			ArithmeticOperator::PLUS
		), ComparingOperator::LESS_OR_EQUAL, null
	);
}

// binary

mapping Sequence(NamedElement)::createBinaryVariable() : Variable {
	log("binary called for: " + self->getVariableName());
	name := self->getVariableName();
	dataType := ILPDataType::BINARY;
}

query Sequence(NamedElement)::getVariableName() : String {
	return '_'.join(self->collect(getVariableName()));
}

query NamedElement::getVariableName() : String {
	// fail in order to detect potential errors
	assert fatal (false) with log("implement me");
	return '';
}

query ComponentInstance::getVariableName() : String {
	return '.'.join(self.getParentComponents()->collect(name));
}

query ComponentInstance::getParentComponents() : OrderedSet(ComponentInstance) {
	return self->asOrderedSet()->closure(ci : ComponentInstance |
		let sci : StructuredComponentInstance = ci.parentCIC.parentStructuredComponentInstance
		in
		if sci.oclIsUndefined() then
			ci->asOrderedSet()
		else
			OrderedSet{ci, sci}
		endif
	)->reverse()->collect(oclAsType(ComponentInstance))->asOrderedSet();
}

query ResourceInstance::getVariableName() : String {
	return self.name;
}

query getVariable(componentInstance : ComponentInstance, resourceInstance : ResourceInstance) : Variable {
	return Sequence{componentInstance, resourceInstance}->map createBinaryVariable();
	/* var varBag : Bag(Variable) := Set{Sequence{componentInstance, resourceInstance}}
		->map createBinaryVariable();
	log("varBag: " + varBag->size().toString());
	assert fatal (varBag->size() = 1) with log("unexpected varBag size (expected: 1)");
	return varBag->any(true);*/
}